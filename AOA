Q1 Write a program to implement insertion sort.

#include <stdio.h>
#include <conio.h>
#define MAX 100

void insertion_sort(int arr[], int n);

void main()
{
    int n, i, a[MAX];
    clrscr();

    printf("\nENTER THE NUMBER OF ELEMENTS TO BE SORTED: ");
    scanf("%d", &n);

    printf("\nENTER %d ELEMENTS IN ARRAY TO SORT:\n", n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }

    printf("\nELEMENTS BEFORE SORTING:\n");
    for (i = 0; i < n; i++)
    {
        printf("%d\t", a[i]);
    }

    insertion_sort(a, n);

    printf("\nELEMENTS AFTER SORTING:\n");
    for (i = 0; i < n; i++)
    {
        printf("%d\t", a[i]);
    }

    getch();
}

void insertion_sort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++)
    {
        key = arr[i];
        j = i - 1;

        // Move elements of arr[0..i-1], that are greater than key, one position ahead
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

Q2 WP to implement MST of prim's algorithm.

#include <stdio.h>
#define SIZE 20
#define INF 32767

void prim(int G[SIZE][SIZE], int nodes) {
    int selected[SIZE] = {0}, i, j, k;
    int total = 0, min, u = 0, v = 0;

    selected[0] = 1; // start from node 0
    printf("\nMinimal Spanning Tree:\n");

    for (k = 1; k < nodes; k++) {
        min = INF;
        for (i = 0; i < nodes; i++) {
            if (selected[i]) {
                for (j = 0; j < nodes; j++) {
                    if (!selected[j] && G[i][j] && G[i][j] < min) {
                        min = G[i][j];
                        u = i;
                        v = j;
                    }
                }
            }
        }
        selected[v] = 1;
        printf("Edge (%d - %d) Weight: %d\n", u, v, min);
        total += min;
    }

    printf("Total Weight: %d\n", total);
}

void main() {
    int G[SIZE][SIZE] = {0}, nodes, edges, i, v1, v2, weight;

    printf("Prim's Algorithm - MST\n");
    printf("Enter number of nodes: ");
    scanf("%d", &nodes);
    printf("Enter number of edges: ");
    scanf("%d", &edges);

    for (i = 0; i < edges; i++) {
        printf("Enter edge (v1 v2) and weight: ");
        scanf("%d %d %d", &v1, &v2, &weight);
        G[v1][v2] = G[v2][v1] = weight;
    }

    prim(G, nodes);
    getch();
}

Q3 Implement Rabin Karp.

#include <stdio.h>
#include <string.h>
#define d 10
void rabinKarp(char pattern[], char text[], int q)
{
int m= strlen(pattern);
int n = strlen(text);
int i, j;
int p = 0;
int t = 0;
int h = 1;
for (i= 0; i< m- 1; i++)
h = (h * d) % q;
// Calculate hash value for pattern and textfor
for(i = 0; i < m; i++) {
p = (d * p + pattern[i]) % q;t
= (d * t +text[i]) % q;
}
// Find the match
for (i= 0; i <= n - m; i++)
{if (p == t) {
for (j= 0; j < m; j++) {
if(text[i+ j] != pattern[j])
break;
}
if(j == m)
printf("Pattern is found at position: %d \n", i+ 1);

}
if(i < n - m) {
t = (d * (t - text[i] * h) + text[i + m]) % q;if
(t < 0)
t = (t + q);
}
}
}
void main()
{
char text[20],pattern[10];
printf("Enter Text:\n");
scanf("%s",text);
printf("Enter Pattern:\n");
scanf("%s",pattern);
int q = 13;
rabinKarp(pattern, text, q);
getch();
}

Q4  WP to implement MST of Kruskal's algorithm.

#include <stdio.h>
#include <stdlib.h>

#define SIZE 20
#define INFINITY 32767

// Structure for an edge
typedef struct {
    int u, v, weight;
} Edge;

// Disjoint-set (Union-Find) functions
int parent[SIZE], rank[SIZE];

// Find function for Union-Find
int find(int i) {
    if (parent[i] == i)
        return i;
    return parent[i] = find(parent[i]);  // Path compression
}

// Union function for Union-Find
void unionSets(int i, int j) {
    int ri = find(i);
    int rj = find(j);

    if (ri != rj) {
        if (rank[ri] > rank[rj])
            parent[rj] = ri;
        else if (rank[ri] < rank[rj])
            parent[ri] = rj;
        else {
            parent[rj] = ri;
            rank[ri]++;
        }
    }
}

void Kruskal(int G[][SIZE], int edges, int nodes) {
    Edge edgeList[SIZE];
    int i, j, e = 0, total = 0;

    // Convert adjacency matrix into edge list
    int k = 0;
    for (i = 0; i < nodes; i++) {
        for (j = i + 1; j < nodes; j++) {
            if (G[i][j] != 0 && G[i][j] != INFINITY) {
                edgeList[k].u = i;
                edgeList[k].v = j;
                edgeList[k].weight = G[i][j];
                k++;
            }
        }
    }

    // Sorting edges by weight using bubble sort (can be optimized)
    for (i = 0; i < edges - 1; i++) {
        for (j = 0; j < edges - i - 1; j++) {
            if (edgeList[j].weight > edgeList[j + 1].weight) {
                Edge temp = edgeList[j];
                edgeList[j] = edgeList[j + 1];
                edgeList[j + 1] = temp;
            }
        }
    }

    // Initialize disjoint sets
    for (i = 0; i < nodes; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    printf("\nThe minimal spanning tree is:\n");

    // Iterate over sorted edges
    for (i = 0; i < edges; i++) {
        int u = edgeList[i].u;
        int v = edgeList[i].v;
        int weight = edgeList[i].weight;

        // Check if adding this edge forms a cycle
        if (find(u) != find(v)) {
            printf("Edge (%d, %d) with weight = %d\n", u, v, weight);
            unionSets(u, v);
            total += weight;
            e++;
            if (e == nodes - 1)
                break;
        }
    }

    printf("\nTotal path length is = %d\n", total);
}

int main() {
    int G[SIZE][SIZE], nodes, edges;
    int v1, v2, length, i, j;

    printf("\nKruskal's Algorithm\n");
    printf("\nEnter the number of nodes in the graph: ");
    scanf("%d", &nodes);

    printf("\nEnter the number of edges in the graph: ");
    scanf("%d", &edges);

    // Initialize graph to infinity
    for (i = 0; i < nodes; i++) {
        for (j = 0; j < nodes; j++) {
            G[i][j] = (i != j) ? INFINITY : 0;
        }
    }

    printf("\nEnter edges and their weights:\n");
    for (i = 0; i < edges; i++) {
        printf("\nEnter edge (v1 and v2) %d: ", i + 1);
        scanf("%d%d", &v1, &v2);

        printf("\nEnter the corresponding weight: ");
        scanf("%d", &length);

        G[v1][v2] = G[v2][v1] = length; // Undirected graph
    }

    Kruskal(G, edges, nodes);

    return 0;
}
